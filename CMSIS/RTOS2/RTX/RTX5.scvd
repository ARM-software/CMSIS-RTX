<?xml version="1.0" encoding="utf-8"?>
<component_viewer schemaVersion="0.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="Component_Viewer.xsd">
  <component name="RTOS" version="5.0.0"/>    <!-- name and version of the component  -->

  <typedefs>
    <!-- Thread Control Block -->
    <typedef name="os_thread_t" info="" size="64">
      <member name="id"            type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"         type="uint8_t"      offset="1" info="Object State">
        <enum name="osThreadInactive"    value="0"  info=""/>
        <enum name="osThreadReady"       value="1"  info=""/>
        <enum name="osThreadRunning"     value="2"  info=""/>
        <enum name="osThreadBlocked"     value="3"  info=""/>
        <enum name="osThreadTerminated"  value="4"  info=""/>
        <enum name="osThreadError"       value="-1" info=""/>

        <enum name="Delay"        value="0x13"  info=""/>
        <enum name="Join"         value="0x23"  info=""/>
        <enum name="Thread Flags" value="0x33"  info=""/>
        <enum name="Event Flags"  value="0x43"  info=""/>
        <enum name="Mutex"        value="0x53"  info=""/>
        <enum name="Semaphore"    value="0x63"  info=""/>
        <enum name="Memory Pool"  value="0x73"  info=""/>
        <enum name="Message Get"  value="0x83"  info=""/>
        <enum name="Message Put"  value="0x93"  info=""/>
      </member>
      <member name="flags"         type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="attr"          type="uint8_t"      offset="3" info="Object Attributes">
        <enum name="osThreadDetached" value="0x00" info="Thread created in detached state"/>
        <enum name="osThreadJoinable" value="0x01" info="Thread created in joinable state"/>
      </member>
      <member name="name"          type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>

      <member name="thread_next"   type="*os_thread_t" offset="8" info="Link pointer to next Thread in Object list"/>
      <member name="thread_prev"   type="*os_thread_t" offset="12" info="Link pointer to previous Thread in Object list"/>
      <member name="delay_next"    type="*os_thread_t" offset="16" info="Link pointer to next Thread in Delay list"/>
      <member name="delay_prev"    type="*os_thread_t" offset="20" info="Link pointer to previous Thread in Delay list"/>
      <member name="thread_join"   type="*os_thread_t" offset="24" info="Thread waiting to Join"/>

      <member name="delay"         type="uint32_t"     offset="28" info="Delay time"/>
      <member name="priority"      type="int8_t"       offset="32" info="Thread priority">
        <enum name="osPriorityNone"         value="0"    info=""/>
        <enum name="osPriorityIdle"         value="1"    info=""/>
        <enum name="osPriorityLow"          value="8"    info=""/>
        <enum name="osPriorityLow1"         value="8+1"  info=""/>
        <enum name="osPriorityLow2"         value="8+2"  info=""/>
        <enum name="osPriorityLow3"         value="8+3"  info=""/>
        <enum name="osPriorityLow4"         value="8+4"  info=""/>
        <enum name="osPriorityLow5"         value="8+5"  info=""/>
        <enum name="osPriorityLow6"         value="8+6"  info=""/>
        <enum name="osPriorityLow7"         value="8+7"  info=""/>
        <enum name="osPriorityBelowNormal"  value="16"   info=""/>
        <enum name="osPriorityBelowNormal1" value="16+1" info=""/>
        <enum name="osPriorityBelowNormal2" value="16+2" info=""/>
        <enum name="osPriorityBelowNormal3" value="16+3" info=""/>
        <enum name="osPriorityBelowNormal4" value="16+4" info=""/>
        <enum name="osPriorityBelowNormal5" value="16+5" info=""/>
        <enum name="osPriorityBelowNormal6" value="16+6" info=""/>
        <enum name="osPriorityBelowNormal7" value="16+7" info=""/>
        <enum name="osPriorityNormal"       value="24"   info=""/>
        <enum name="osPriorityNormal1"      value="24+1" info=""/>
        <enum name="osPriorityNormal2"      value="24+2" info=""/>
        <enum name="osPriorityNormal3"      value="24+3" info=""/>
        <enum name="osPriorityNormal4"      value="24+4" info=""/>
        <enum name="osPriorityNormal5"      value="24+5" info=""/>
        <enum name="osPriorityNormal6"      value="24+6" info=""/>
        <enum name="osPriorityNormal7"      value="24+7" info=""/>
        <enum name="osPriorityAboveNormal"  value="32"   info=""/>
        <enum name="osPriorityAboveNormal1" value="32+1" info=""/>
        <enum name="osPriorityAboveNormal2" value="32+2" info=""/>
        <enum name="osPriorityAboveNormal3" value="32+3" info=""/>
        <enum name="osPriorityAboveNormal4" value="32+4" info=""/>
        <enum name="osPriorityAboveNormal5" value="32+5" info=""/>
        <enum name="osPriorityAboveNormal6" value="32+6" info=""/>
        <enum name="osPriorityAboveNormal7" value="32+7" info=""/>
        <enum name="osPriorityHigh"         value="40"   info=""/>
        <enum name="osPriorityHigh1"        value="40+1" info=""/>
        <enum name="osPriorityHigh2"        value="40+2" info=""/>
        <enum name="osPriorityHigh3"        value="40+3" info=""/>
        <enum name="osPriorityHigh4"        value="40+4" info=""/>
        <enum name="osPriorityHigh5"        value="40+5" info=""/>
        <enum name="osPriorityHigh6"        value="40+6" info=""/>
        <enum name="osPriorityHigh7"        value="40+7" info=""/>
        <enum name="osPriorityRealtime"     value="48"   info=""/>
        <enum name="osPriorityRealtime1"    value="48+1" info=""/>
        <enum name="osPriorityRealtime2"    value="48+2" info=""/>
        <enum name="osPriorityRealtime3"    value="48+3" info=""/>
        <enum name="osPriorityRealtime4"    value="48+4" info=""/>
        <enum name="osPriorityRealtime5"    value="48+5" info=""/>
        <enum name="osPriorityRealtime6"    value="48+6" info=""/>
        <enum name="osPriorityRealtime7"    value="48+7" info=""/>
        <enum name="osPriorityISR"          value="56"   info=""/>
        <enum name="osPriorityError"        value="-1"   info=""/>
      </member>
      <member name="priority_base" type="int8_t"       offset="33" info="Base priority"/>
      <member name="stack_frame"   type="uint8_t"      offset="34" info="Stack frame"/>
      <member name="flags_options" type="uint8_t"      offset="35" info="Thread/Event flags options">
        <enum name="osFlagsWaitAny"   value="0x00" info="Wait for any flag."/>
        <enum name="osFlagsWaitAll"   value="0x01" info="Wait for all flags."/>
        <enum name="osFlagsAutoClear" value="0x02" info="Clear flags which have been specified to wait for."/>
      </member>
      <member name="wait_flags"    type="int32_t"      offset="36" info="Waiting Thread/Event flags"/>
      <member name="thread_flags"  type="int32_t"      offset="40" info="Thread flags"/>
      <member name="mutex_list"    type="*os_mutex_t"  offset="44" info="Link pointer to list of owned mutexes"/>
      <member name="stack_mem"     type="uint32_t"     offset="48" info="Stack memory (type is void *)"/>
      <member name="stack_size"    type="uint32_t"     offset="52" info="Stack size"/>
      <member name="sp"            type="uint32_t"     offset="56" info="Current stack pointer"/>
      <member name="tz_memory"     type="uint32_t"     offset="60" info="TrustZone Memory Identifier"/>

      <var name="obj_name"   type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid"   type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="cb_id"      type="uint8_t"  info="Component View ID"/>

      <var name="ex_delay"   type="uint32_t" info="Calculated execution delay"/>

      <var name="stack_val"  type="uint32_t" info="Stack usage: analysis result"/>
      <var name="stack_curp" type="uint32_t" info="Stack usage: current (in percent)"/>
      <var name="stack_curb" type="uint32_t" info="Stack usage: current (in bytes)"/>
      <var name="stack_maxb" type="uint32_t" info="Stack usage: maximum (in bytes)"/>
      <var name="stack_maxp" type="uint32_t" info="Stack usage: maximum (in percent)"/>
      <var name="stack_over" type="uint8_t"  info="Stack usage: overflow"/>
    </typedef>

    <!-- Timer Control Block -->
    <typedef name="os_timer_t" info="" size="32">
      <member name="id"          type="uint8_t"     offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"     offset="1" info="Object State">
        <enum name="Inactive" value="0" info="Timer is not active"/>
        <enum name="Stopped"  value="1" info="Timer is stopped"/>
        <enum name="Running"  value="2" info="Timer is running"/>
      </member>
      <member name="flags"       type="uint8_t"     offset="2" info="Object Flags"/>
      <member name="type"        type="uint8_t"     offset="3" info="Timer Type">
        <enum name="osTimerOnce"     value="0" info="One-shot timer"/>
        <enum name="osTimerPeriodic" value="1" info="Periodic timer"/>
      </member>
      <member name="name"        type="uint32_t"    offset="4" info="Object name (type is *uint8_t)"/>
      <member name="prev"        type="*os_timer_t" offset="8" info="Pointer to previous active timer"/>
      <member name="next"        type="*os_timer_t" offset="12" info="Pointer to next active timer"/>
      <member name="tick"        type="uint32_t"    offset="16" info="Timer current tick"/>
      <member name="load"        type="uint32_t"    offset="20" info="Timer load value"/>
      <!-- Inlined "os_timer_finfo_t" structure -->
      <member name="finfo_fp"    type="uint32_t"    offset="24" info="Timer function pointer (type is void *)"/>
      <member name="finfo_arg"   type="uint32_t"    offset="28" info="Timer function argument (type is void *)"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="ex_tick"  type="uint32_t" info="Calculated absolute tick time"/>
    </typedef>

    <!-- Event Flags Control Block -->
    <typedef name="os_event_flags_t" info="" size="16">
      <member name="id"          type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"      offset="1" info="Object State"/>
      <member name="flags"       type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="reserved"    type="uint8_t"      offset="3" info=""/>
      <member name="name"        type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list" type="*os_thread_t" offset="8" info="Waiting threads list"/>
      <member name="event_flags" type="int32_t"      offset="12" info="Event flags"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="wl_idx"   type="uint32_t" info="EventFlags waiting list (EWL) index" />
      <var name="wl_cnt"   type="uint32_t" info="Number of threads waiting for event flags" />
    </typedef>

    <!-- Mutex Control Block -->
    <typedef name="os_mutex_t" info="" size="28">
      <member name="id"           type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"        type="uint8_t"      offset="1" info="Object State"/>
      <member name="flags"        type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="attr"         type="uint8_t"      offset="3" info="Object Attributes">
        <enum name="osMutexRecursive"   value="0x01" info="Recursive mutex."/>
        <enum name="osMutexPrioInherit" value="0x02" info="Priority inherit protocol."/>
        <enum name="osMutexRobust"      value="0x08" info="Robust mutex."/>
      </member>
      <member name="name"         type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list"  type="*os_thread_t" offset="8" info="Waiting threads list"/>
      <member name="owner_thread" type="*os_thread_t" offset="12" info="Owner thread"/>
      <member name="owner_prev"   type="*os_mutex_t"  offset="16" info="Pointer to previous owned mutex"/>
      <member name="owner_next"   type="*os_mutex_t"  offset="20" info="Pointer to next owned mutex"/>
      <member name="lock"         type="uint8_t"      offset="24" info="Lock counter"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="wl_idx"   type="uint32_t" info="Mutex waiting list (MWL) index" />
      <var name="wl_cnt"   type="uint32_t" info="Number of threads waiting for current mutex" />
    </typedef>

    <!-- Semaphore Control Block -->
    <typedef name="os_semaphore_t" info="" size="16">
      <member name="id"          type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"      offset="1" info="Object State"/>
      <member name="flags"       type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="reserved"    type="uint8_t"      offset="3" info=""/>
      <member name="name"        type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list" type="*os_thread_t" offset="8" info="Waiting threads list"/>
      <member name="tokens"      type="uint16_t"     offset="12" info="Current number of tokens"/>
      <member name="max_tokens"  type="uint16_t"     offset="14" info="Maximum number of tokens"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="wl_idx"   type="uint32_t" info="Semaphore waiting list (SWL) index" />
      <var name="wl_cnt"   type="uint32_t" info="Number of threads waiting for current semaphore" />
    </typedef>

    <!-- Memory Pool Information -->
    <typedef name="os_mp_info_t" info="Memory pool information" size="24">
      <member name="max_blocks"  type="uint32_t" offset="0" info="Maximum number of blocks"/>
      <member name="used_blocks" type="uint32_t" offset="4" info="Number of used blocks"/>
      <member name="block_size"  type="uint32_t" offset="8" info="Block size"/>
      <member name="block_base"  type="uint32_t" offset="12" info="Block memory base address (type is void *)"/>
      <member name="block_lim"   type="uint32_t" offset="16" info="Block memory limit address (type is void *)"/>
      <member name="block_free"  type="uint32_t" offset="20" info="First free block address (type is void *)"/>
    </typedef>

    <!-- Memory Pool Control Block -->
    <typedef name="os_memory_pool_t" info="" size="36">
      <member name="id"          type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"      offset="1" info="Object State"/>
      <member name="flags"       type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="reserved"    type="uint8_t"      offset="3" info=""/>
      <member name="name"        type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list" type="*os_thread_t" offset="8" info="Waiting threads list"/>

      <!-- Inlined "os_mp_info_t" structure -->
      <member name="max_blocks"  type="uint32_t" offset="12+0" info="Maximum number of blocks"/>
      <member name="used_blocks" type="uint32_t" offset="12+4" info="Number of used blocks"/>
      <member name="block_size"  type="uint32_t" offset="12+8" info="Block size"/>
      <member name="block_base"  type="uint32_t" offset="12+12" info="Block memory base address (type is void *)"/>
      <member name="block_lim"   type="uint32_t" offset="12+16" info="Block memory limit address (type is void *)"/>
      <member name="block_free"  type="uint32_t" offset="12+20" info="First free block address (type is void *)"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="wl_idx"   type="uint32_t" info="Memory Pool waiting list (PWL) index" />
      <var name="wl_cnt"   type="uint32_t" info="Number of threads waiting for memory pool" />
    </typedef>

    <!-- Message Control Block -->
    <typedef name="os_message_t" info="" size="12">
      <member name="id"       type="uint8_t"       offset="0" info="Object Identifier"/>
      <member name="state"    type="uint8_t"       offset="1" info="Object State"/>
      <member name="flags"    type="uint8_t"       offset="2" info="Object Flags"/>
      <member name="priority" type="uint8_t"       offset="3" info="Message priority"/>
      <member name="prev"     type="*os_message_t" offset="4" info="Pointer to previous message"/>
      <member name="next"     type="*os_message_t" offset="8" info="Pointer to next message"/>

      <var name="addr" type="uint32_t" info="Message location address" />
    </typedef>

    <!-- Message Queue Control Block -->
    <typedef name="os_message_queue_t" info="" size="52">
      <member name="id"          type="uint8_t"       offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"       offset="1" info="Object State"/>
      <member name="flags"       type="uint8_t"       offset="2" info="Object Flags"/>
      <member name="reserved"    type="uint8_t"       offset="3" info=""/>
      <member name="name"        type="uint32_t"      offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list" type="*os_thread_t"  offset="8" info="Waiting threads list"/>

      <!-- Inlined "os_mp_info_t" structure -->
      <member name="max_blocks"  type="uint32_t"      offset="12+0" info="Maximum number of blocks"/>
      <member name="used_blocks" type="uint32_t"      offset="12+4" info="Number of used blocks"/>
      <member name="block_size"  type="uint32_t"      offset="12+8" info="Block size"/>
      <member name="block_base"  type="uint32_t"      offset="12+12" info="Block memory base address (type is void *)"/>
      <member name="block_lim"   type="uint32_t"      offset="12+16" info="Block memory limit address (type is void *)"/>
      <member name="block_free"  type="uint32_t"      offset="12+20" info="First free block address (type is void *)"/>

      <member name="msg_size"    type="uint32_t"      offset="36" info="Message size"/>
      <member name="msg_count"   type="uint32_t"      offset="40" info="Number of queued messages"/>
      <member name="msg_first"   type="*os_message_t" offset="44" info="Pointer to first message"/>
      <member name="msg_last"    type="*os_message_t" offset="48" info="Pointer to last message"/>

      <var name="obj_name" type="uint8_t"  info="Object name string" size="66" />
      <var name="cb_valid" type="uint32_t" info="Control Block validation status (valid=1, invalid=0)"/>
      <var name="wl_idx"   type="uint32_t" info="Waiting list index (QWL)" />
      <var name="wl_cnt"   type="uint32_t" info="Number of threads waiting" />
      <var name="ml_idx"   type="uint32_t" info="Queue message list index (QML)" />
      <var name="ml_cnt"   type="uint32_t" info="Number of messages queued" />
    </typedef>

    <!-- Generic Object Control Block -->
    <typedef name="os_object_t" info="" size="12">
      <member name="id"          type="uint8_t"      offset="0" info="Object Identifier"/>
      <member name="state"       type="uint8_t"      offset="1" info="Object State"/>
      <member name="flags"       type="uint8_t"      offset="2" info="Object Flags"/>
      <member name="reserved"    type="uint8_t"      offset="3" info=""/>
      <member name="name"        type="uint32_t"     offset="4" info="Object name (type is *uint8_t)"/>
      <member name="thread_list" type="*os_thread_t" offset="8" info="Threads list"/>
    </typedef>

    <!-- OS Runtime Information structure -->
    <typedef name="os_info_t" info="OS Runtime Information" size="168">
      <member name="os_id"                      type="uint32_t"      offset="0" info="OS Identification (type is *uint8_t)"/>
      <member name="version"                    type="uint32_t"      offset="4" info="OS Version"/>
      <member name="kernel_state"               type="uint8_t"       offset="8" info="Kernel state">
        <enum name="osKernelInactive"  value="0"  info="Inactive"/>
        <enum name="osKernelReady"     value="1"  info="Ready"/>
        <enum name="osKernelRunning"   value="2"  info="Running"/>
        <enum name="osKernelLocked"    value="3"  info="Locked"/>
        <enum name="osKernelSuspended" value="4"  info="Suspended"/>
        <enum name="osKernelError"     value="5"  info="Error"/>
      </member>
      <member name="kernel_blocked"             type="uint8_t"       offset="9" info="Kernel blocked"/>
      <member name="kernel_pendISR"             type="uint8_t"       offset="10" info="Kernel pending ISR"/>
      <member name="kernel_pendSV"              type="uint8_t"       offset="11" info="Kernel pending SV"/>
      <member name="kernel_sys_freq"            type="uint32_t"      offset="12" info="Kernel system frequency"/>
      <member name="kernel_tick"                type="uint64_t"      offset="16" info="Kernel tick counter"/>

      <member name="tick_irqn"                  type="int32_t"       offset="24" info="Tick timer IRQ number"/>

      <member name="thread_run_curr"            type="*os_thread_t"  offset="28" info="Current running thread"/>
      <member name="thread_run_next"            type="*os_thread_t"  offset="32" info="Next thread to run"/>

      <!-- Inlined "os_object_t" structure at offset: 36 -->
      <!-- <member name="thread_ready"          type="os_object_t"  offset="36" info="Ready list object"/>-->
      <member name="thread_ready_id"            type="uint8_t"       offset="36+0" info="Object Identifier" />
      <member name="thread_ready_state"         type="uint8_t"       offset="36+1" info="Object State" />
      <member name="thread_ready_flags"         type="uint8_t"       offset="36+2" info="Object Flags" />
      <member name="thread_ready_rsvd"          type="uint8_t"       offset="36+3" info="Reserved" />
      <member name="thread_ready_name"          type="uint32_t"      offset="36+4" info="Object Name (type is *uint8_t)" />
      <member name="thread_ready_thread_list"   type="*os_thread_t"  offset="36+8" info="Threads List" />

      <member name="thread_idle"                type="*os_thread_t"  offset="48" info="Idle thread"/>
      <member name="thread_delay_list"          type="*os_thread_t"  offset="52" info="Delay list"/>
      <member name="thread_wait_list"           type="*os_thread_t"  offset="56" info="Wait list (no timeout)"/>
      <member name="thread_terminate_list"      type="*os_thread_t"  offset="60" info="Terminate list"/>

      <member name="thread_robin_thread"        type="*os_thread_t"  offset="64" info="Round Robin thread"/>
      <member name="thread_robin_tick"          type="uint32_t"      offset="68" info="Round Robin time tick"/>
      <member name="thread_timeout"             type="uint32_t"      offset="72" info="Round Robin timeout"/>

      <member name="timer_list"                 type="*os_timer_t"   offset="76" info="Active timer list"/>
      <member name="timer_thread"               type="*os_thread_t"  offset="80" info="Timer thread"/>
      <member name="timer_mq"                   type="*os_message_queue_t" offset="84" info="Timer message queue"/>

      <member name="isr_queue_max"              type="uint16_t"      offset="88" info="Maximum items"/>
      <member name="isr_queue_cnt"              type="uint16_t"      offset="90" info="Item count"/>
      <member name="isr_queue_in"               type="uint16_t"      offset="92" info="Incoming item index"/>
      <member name="isr_queue_out"              type="uint16_t"      offset="94" info="Outgoing item index"/>
      <member name="isr_queue_data"             type="uint32_t"      offset="96" info="Queue data (value is void **)"/>

      <member name="post_process_thread"        type="uint32_t"      offset="100" info="Thread post processing function (value is func *)"/>
      <member name="post_process_event_flags"   type="uint32_t"      offset="104" info="Event flags post processing function (value is func *)"/>
      <member name="post_process_semaphore"     type="uint32_t"      offset="108" info="Semaphore post processing function (value is func *)"/>
      <member name="post_process_memory_pool"   type="uint32_t"      offset="112" info="Memory pool post processing function (value is func *)"/>
      <member name="post_process_message_queue" type="uint32_t"      offset="116" info="Message queue post processing function (value is func *)"/>

      <member name="mem_stack"                  type="uint32_t"      offset="120" info="Stack memory (value is void *)"/>
      <member name="mem_mp_data"                type="uint32_t"      offset="124" info="Memory pool data memory (value is void *)"/>
      <member name="mem_mq_data"                type="uint32_t"      offset="128" info="Message queue Data memory (value is void *)"/>
      <member name="mem_common"                 type="uint32_t"      offset="132" info="Common memory address (value is void *)"/>

      <member name="mpi_stack"                  type="*os_mp_info_t" offset="136" info="Stack for threads"/>
      <member name="mpi_thread"                 type="*os_mp_info_t" offset="140" info="Thread control blocks"/>
      <member name="mpi_timer"                  type="*os_mp_info_t" offset="144" info="Timer control blocks"/>
      <member name="mpi_event_flags"            type="*os_mp_info_t" offset="148" info="Event flags control blocks"/>
      <member name="mpi_mutex"                  type="*os_mp_info_t" offset="152" info="Mutex control blocks"/>
      <member name="mpi_semaphore"              type="*os_mp_info_t" offset="156" info="Semaphore control blocks"/>
      <member name="mpi_memory_pool"            type="*os_mp_info_t" offset="160" info="Memory pool control blocks"/>
      <member name="mpi_message_queue"          type="*os_mp_info_t" offset="164" info="Message queue control blocks"/>
    </typedef>

    <!-- OS Configuration structure -->
    <typedef name="os_config_t" const="1" info="OS Configuration Structure" size="100">
      <member name="flags"                 type="uint32_t" offset="0" info="OS configuration flags"/>
      <member name="tick_freq"             type="uint32_t" offset="4" info="Kernel tick frequency"/>

      <member name="robin_timeout"         type="uint32_t" offset="8" info="Round Robim timeout tick"/>
      <member name="isr_queue_data"        type="uint32_t" offset="12" info="ISR post processing queue (value is void **)"/>
      <member name="isr_queue_max"         type="uint16_t" offset="14" info="Maximum data"/>
      <member name="isr_queue_padding"     type="uint16_t" offset="16" info="Padding bytes"/>

      <member name="mem_stack_addr"        type="uint32_t" offset="20" info="Stack memory address"/>
      <member name="mem_stack_size"        type="uint32_t" offset="24" info="Stack memory size"/>
      <member name="mem_mp_data_addr"      type="uint32_t" offset="28" info="Memory pool data memory address"/>
      <member name="mem_mp_data_size"      type="uint32_t" offset="32" info="Memory pool data memory size"/>
      <member name="mem_mq_data_addr"      type="uint32_t" offset="36" info="Message queue data memory address"/>
      <member name="mem_mq_data_size"      type="uint32_t" offset="40" info="Message queue data memory size"/>
      <member name="mem_common_addr"       type="uint32_t" offset="44" info="Common memory address"/>
      <member name="mem_common_size"       type="uint32_t" offset="48" info="Common memory size"/>

      <member name="mpi_stack"             type="*os_mp_info_t" offset="52" info="Stack for threads"/>
      <member name="mpi_thread"            type="*os_mp_info_t" offset="56" info="Thread control blocks"/>
      <member name="mpi_timer"             type="*os_mp_info_t" offset="60" info="Timer control blocks"/>
      <member name="mpi_event_flags"       type="*os_mp_info_t" offset="64" info="Event flags control blocks"/>
      <member name="mpi_mutex"             type="*os_mp_info_t" offset="68" info="Mutex control blocks"/>
      <member name="mpi_semaphore"         type="*os_mp_info_t" offset="72" info="Semaphore control blocks"/>
      <member name="mpi_memory_pool"       type="*os_mp_info_t" offset="76" info="Memory pool control blocks"/>
      <member name="mpi_message_queue"     type="*os_mp_info_t" offset="80" info="Message queue control blocks"/>

      <member name="thread_stack_size"     type="uint32_t" offset="84"  info="Default thread stack size"/>
      <member name="idle_thread_attr"      type="uint32_t" offset="88"  info="Idle thread attributes (value is osThreadAttr_s *)"/>
      <member name="timer_thread_attr"     type="uint32_t" offset="92"  info="Timer thread attributes (value is osThreadAttr_s *)"/>
      <member name="timer_mq_attr"         type="uint32_t" offset="96"  info="Timer message queue attributes (value is osMessageQueueAttr_s *)"/>
      <member name="timer_mq_mcnt"         type="uint32_t" offset="100" info="Timer message queue maximum messages"/>
    </typedef>

    <!-- Memory Pool Header -->
    <typedef name="mem_head_t" info="Memory Pool Header Structure" size="8">
      <member name="size" type="uint32_t" offset="0" info="Memory pool size"/>
      <member name="used" type="uint32_t" offset="4" info="Size of used memory"/>
    </typedef>

    <!-- Memory Block Header + Object Header -->
    <typedef name="mem_block_t" info="Memory Block Header Structure" size="9">
      <member name="next"     type="*mem_block_t" offset="0"  info="Next memory block"/>
      <member name="len"      type="uint32_t"     offset="4"  info="Memory block size"/>
      <member name="id"       type="uint8_t"      offset="8"  info="Object Identifier"/>
    </typedef>

  </typedefs>

  <objects>
    <object name="RTX RTOS Object">
      <var name="i"    type="uint32_t" value="0" />
      <var name="j"    type="uint32_t" value="0" />
      <var name="k"    type="uint32_t" value="0" />
      <var name="n"    type="uint32_t" value="0" />
      <var name="sp"   type="uint32_t" value="0" />
      <var name="addr" type="uint32_t" value="0" />

      <var name="RTX_En" type="uint8_t" value="0" />
      <var name="TCB_En" type="uint8_t" value="0" />
      <var name="CCB_En" type="uint8_t" value="0" />
      <var name="SCB_En" type="uint8_t" value="0" />
      <var name="MCB_En" type="uint8_t" value="0" />
      <var name="ECB_En" type="uint8_t" value="0" />
      <var name="PCB_En" type="uint8_t" value="0" />
      <var name="QCB_En" type="uint8_t" value="0" />

      <var name="StaticMp_En" type="uint8_t" value="0" />

      <!-- Read main OS information and configuration structures -->
      <readlist name="os_Info"   type="os_info_t"   symbol="os_Info"   count="1" init="1"/>
      <readlist name="os_Config" type="os_config_t" symbol="os_Config" count="1" init="1"/>

      <!-- Read statically allocated control blocks -->
      <readlist name="cfg_mp_thread"    cond="os_Config.mpi_thread"        type="os_mp_info_t" offset="os_Config.mpi_thread"        const="1" count="1" init="1"/>
      <readlist name="cfg_mp_timer"     cond="os_Config.mpi_timer"         type="os_mp_info_t" offset="os_Config.mpi_timer"         const="1" count="1" init="1"/>
      <readlist name="cfg_mp_events"    cond="os_Config.mpi_event_flags"   type="os_mp_info_t" offset="os_Config.mpi_event_flags"   const="1" count="1" init="1"/>
      <readlist name="cfg_mp_mutex"     cond="os_Config.mpi_mutex"         type="os_mp_info_t" offset="os_Config.mpi_mutex"         const="1" count="1" init="1"/>
      <readlist name="cfg_mp_semaphore" cond="os_Config.mpi_semaphore"     type="os_mp_info_t" offset="os_Config.mpi_semaphore"     const="1" count="1" init="1"/>
      <readlist name="cfg_mp_mpool"     cond="os_Config.mpi_memory_pool"   type="os_mp_info_t" offset="os_Config.mpi_memory_pool"   const="1" count="1" init="1"/>
      <readlist name="cfg_mp_mqueue"    cond="os_Config.mpi_message_queue" type="os_mp_info_t" offset="os_Config.mpi_message_queue" const="1" count="1" init="1"/>

      <calc cond="((os_Info.version / 10000000) == 5) &amp;&amp; (os_Info.kernel_state &gt; 0) &amp;&amp; (os_Info.kernel_state &lt; 5)">
        RTX_En = 1;
      </calc>

      <calc cond="RTX_En &amp;&amp; (os_Config.mpi_thread || os_Config.mpi_timer || os_Config.mpi_event_flags || os_Config.mpi_mutex || os_Config.mpi_semaphore || os_Config.mpi_memory_pool || os_Config.mpi_message_queue)">
        StaticMp_En = 1;
      </calc>

      <var name="stack_check" type="uint8_t" value="(os_Config.flags >> 1) &amp; 1"/>
      <var name="stack_wmark" type="uint8_t" value="(os_Config.flags >> 2) &amp; 1"/>

      <!-- Read ISR FIFO queue -->
      <read name="ISR_FIFO" cond="RTX_En" type="uint32_t" offset="os_Config.isr_queue_data" size="os_Config.isr_queue_max"/>

      <!-- Read idle and timer thread control blocks -->
      <readlist name="TCB" cond="RTX_En &amp;&amp; os_Info.thread_idle"  type="os_thread_t" offset="os_Info.thread_idle"  count="1" />
      <readlist name="TCB" cond="RTX_En &amp;&amp; os_Info.timer_thread" type="os_thread_t" offset="os_Info.timer_thread" count="1" />

      <!-- Read thread control blocks (MPI) -->
      <readlist name="mp_thread" cond="RTX_En &amp;&amp; os_Info.mpi_thread" type="os_mp_info_t" offset="os_Info.mpi_thread"   count="1" init="1"/>
      <readlist name="TCB"       cond="RTX_En &amp;&amp; os_Info.mpi_thread" type="os_thread_t"  offset="mp_thread.block_base" count="mp_thread.max_blocks" />

      <!-- Read timer control blocks (MPI) -->
      <readlist name="mp_timer" cond="RTX_En &amp;&amp; os_Info.mpi_timer" type="os_mp_info_t" offset="os_Info.mpi_timer"   count="1" init="1"/>
      <readlist name="CCB"      cond="RTX_En &amp;&amp; os_Info.mpi_timer" type="os_timer_t"   offset="mp_timer.block_base" count="mp_timer.max_blocks" />

      <!-- Read event flags control blocks (MPI) -->
      <readlist name="mp_events" cond="RTX_En &amp;&amp; os_Info.mpi_event_flags" type="os_mp_info_t"     offset="os_Info.mpi_event_flags" count="1" init="1"/>
      <readlist name="ECB"       cond="RTX_En &amp;&amp; os_Info.mpi_event_flags" type="os_event_flags_t" offset="mp_events.block_base"    count="mp_events.max_blocks" />

      <!-- Read mutex control blocks (MPI) -->
      <readlist name="mp_mutex" cond="RTX_En &amp;&amp; os_Info.mpi_mutex" type="os_mp_info_t" offset="os_Info.mpi_mutex"   count="1" init="1"/>
      <readlist name="MCB"      cond="RTX_En &amp;&amp; os_Info.mpi_mutex" type="os_mutex_t"   offset="mp_mutex.block_base" count="mp_mutex.max_blocks" />

      <!-- Read semaphore control blocks (MPI) -->
      <readlist name="mp_semaphore" cond="RTX_En &amp;&amp; os_Info.mpi_semaphore" type="os_mp_info_t"   offset="os_Info.mpi_semaphore"   count="1" init="1"/>
      <readlist name="SCB"          cond="RTX_En &amp;&amp; os_Info.mpi_semaphore" type="os_semaphore_t" offset="mp_semaphore.block_base" count="mp_semaphore.max_blocks" />

      <!-- Read memory pool control blocks (MPI) -->
      <readlist name="mp_mpool" cond="RTX_En &amp;&amp; os_Info.mpi_memory_pool" type="os_mp_info_t"     offset="os_Info.mpi_memory_pool" count="1" init="1"/>
      <readlist name="PCB"      cond="RTX_En &amp;&amp; os_Info.mpi_memory_pool" type="os_memory_pool_t" offset="mp_mpool.block_base"     count="mp_mpool.max_blocks" />

      <!-- Read message queue control blocks (MPI) -->
      <readlist name="mp_mqueue" cond="RTX_En &amp;&amp; os_Info.mpi_message_queue" type="os_mp_info_t"       offset="os_Info.mpi_message_queue" count="1" init="1"/>
      <readlist name="QCB"       cond="RTX_En &amp;&amp; os_Info.mpi_message_queue" type="os_message_queue_t" offset="mp_mqueue.block_base"      count="mp_mqueue.max_blocks" />

      <!-- Read common memory pool block info (MEM) -->
      <readlist name="mem_bl" cond="RTX_En &amp;&amp; os_Info.mem_common" type="mem_block_t" offset="os_Info.mem_common + 8" next="next"/>

      <list cond="mem_bl._count > 1" name="i" start="0" limit="mem_bl._count-1">
        <calc>
          addr  = mem_bl[i]._addr;
          addr += 8;
        </calc>

        <!-- Read Thread Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 1)" name="TCB" type="os_thread_t" offset="addr" count="1" />

        <!-- Read Timer Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 2)" name="CCB" type="os_timer_t" offset="addr" count="1" />

        <!-- Read EventFlags Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 3)" name="ECB" type="os_event_flags_t" offset="addr" count="1" />

        <!-- Read Mutex Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 4)" name="MCB" type="os_mutex_t" offset="addr" count="1" />

        <!-- Read Semaphore Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 5)" name="SCB" type="os_semaphore_t" offset="addr" count="1" />

        <!-- Read MemoryPool Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 6)" name="PCB" type="os_memory_pool_t" offset="addr" count="1" />

        <!-- Read MessageQueue Control Block -->
        <readlist cond="(mem_bl[i].len &amp; 1) &amp;&amp; (mem_bl[i].id == 8)" name="QCB" type="os_message_queue_t" offset="addr" count="1" />
      </list>

      <!-- Read thread wait list -->
      <readlist name="TWL" cond="RTX_En &amp;&amp; os_Info.thread_wait_list" type="os_thread_t" offset="os_Info.thread_wait_list" next="delay_next"/>

      <!-- Validate and process Thread control blocks -->
      <list name="i" start="0" limit="TCB._count">
        <calc>
          TCB[i].cb_valid = (TCB[i].id == 1) &amp;&amp; (TCB[i].state != 0) &amp;&amp; (TCB[i].sp != 0);
          TCB[i].cb_id = 2;
        </calc>
        <calc cond="TCB[i]._addr == os_Info.timer_thread">
          TCB[i].cb_id = 1;

          TCB[i].obj_name[0]  = ',';
          TCB[i].obj_name[1]  = ' ';
          TCB[i].obj_name[2]  = 'T';
          TCB[i].obj_name[3]  = 'i';
          TCB[i].obj_name[4]  = 'm';
          TCB[i].obj_name[5]  = 'e';
          TCB[i].obj_name[6]  = 'r';
          TCB[i].obj_name[7]  = ' ';
          TCB[i].obj_name[8]  = 'T';
          TCB[i].obj_name[9]  = 'h';
          TCB[i].obj_name[10] = 'r';
          TCB[i].obj_name[11] = 'e';
          TCB[i].obj_name[12] = 'a';
          TCB[i].obj_name[13] = 'd';
          TCB[i].obj_name[14] = '\0';
        </calc>
        <calc cond="TCB[i]._addr == os_Info.thread_idle">
          TCB[i].cb_id = 0;

          TCB[i].obj_name[0]  = ',';
          TCB[i].obj_name[1]  = ' ';
          TCB[i].obj_name[2]  = 'I';
          TCB[i].obj_name[3]  = 'd';
          TCB[i].obj_name[4]  = 'l';
          TCB[i].obj_name[5]  = 'e';
          TCB[i].obj_name[6]  = ' ';
          TCB[i].obj_name[7]  = 'T';
          TCB[i].obj_name[8]  = 'h';
          TCB[i].obj_name[9]  = 'r';
          TCB[i].obj_name[10] = 'e';
          TCB[i].obj_name[11] = 'a';
          TCB[i].obj_name[12] = 'd';
          TCB[i].obj_name[13] = '\0';
        </calc>

        <!-- Determine stack usage -->
        <calc cond="TCB[i].sp != 0">
          TCB[i].stack_val  = __CalcMemUsed (TCB[i].stack_mem, TCB[i].stack_size, 0xCCCCCCCC, 0xE25A2EA5);
          TCB[i].stack_over = TCB[i].stack_val >> 31;
          TCB[i].stack_maxb = TCB[i].stack_over ? TCB[i].stack_size : TCB[i].stack_val &amp; 0xFFFFF;
          TCB[i].stack_maxp = TCB[i].stack_over ? 100 : (TCB[i].stack_val >> 20) &amp; 0x1FF;
        </calc>

        <!-- Stack pointer for running thread -->
        <calc cond="TCB[i].state == 2">
          sp = __GetRegVal ("PSP");
        </calc>

        <!-- Stack pointer for waiting thread -->
        <calc cond="TCB[i].state != 2">
          sp = TCB[i].sp;
        </calc>

        <!-- Determine current stack usage -->
        <calc cond="TCB[i].sp != 0">
          TCB[i].stack_curb  = TCB[i].stack_mem + TCB[i].stack_size;
          TCB[i].stack_curb -= sp;
          TCB[i].stack_curp  = TCB[i].stack_curb;
          TCB[i].stack_curp *= 100;
          TCB[i].stack_curp /= TCB[i].stack_size;
        </calc>

        <calc>
          TCB[i].ex_delay = TCB[i].delay;
        </calc>

        <!-- Create Thread Delay List (TDL) -->
        <readlist cond="TCB[i].delay != -1" name="TDL" type="os_thread_t" offset="TCB[i].delay_prev" next="delay_prev" init="1"/>

        <list cond="TCB[i].delay != -1" name="j" start="0" limit="TDL._count">
          <calc>
            TCB[i].ex_delay += TDL[j].delay;
          </calc>
        </list>

        <!-- Read name string -->
        <calc cond="(TCB[i].name != 0) &amp;&amp; (TCB[i].cb_id &gt; 1)">
          TCB[i].obj_name[0] = ',';
          TCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="TCB[i].name" name="n" start="0" limit="64">
          <read name="ch0" type="uint8_t" offset="TCB[i].name + n"/>

          <calc>
            TCB[i].obj_name[2+n] = ch0;
          </calc>

          <calc cond="ch0 == 0">
            n = 64;
          </calc>
        </list>

      </list>

      <!-- Validate and process Timer control blocks -->
      <list name="i" start="0" limit="CCB._count">
        <calc>
          CCB[i].cb_valid = (CCB[i].id == 2) &amp;&amp; (CCB[i].state != 0);
          CCB[i].ex_tick  = CCB[i].tick;
        </calc>

        <!-- Create Timer Execution List (TEL) -->
        <readlist name="TEL" type="os_timer_t" offset="CCB[i].prev" next="prev" init="1"/>

        <list name="j" start="0" limit="TEL._count">
          <calc>
            CCB[i].ex_tick += TEL[j].tick;
          </calc>
        </list>

        <!-- Read name string -->
        <calc cond="CCB[i].name">
          CCB[i].obj_name[0] = ',';
          CCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="CCB[i].name" name="n" start="0" limit="64">
          <read name="ch1" type="uint8_t" offset="CCB[i].name + n"/>

          <calc>
            CCB[i].obj_name[2+n] = ch1;
          </calc>

          <calc cond="ch1 == 0">
            n = 64;
          </calc>
        </list>
      </list>

      <!-- Validate and process EventFlags control blocks -->
      <calc> k = 0; </calc>

      <list name="i" start="0" limit="ECB._count">
        <calc>
          ECB[i].cb_valid = (ECB[i].id == 3) &amp;&amp; (ECB[i].state == 1);
          ECB[i].wl_idx   = k;
        </calc>

        <!-- Create a list of threads waiting for event flags -->
        <readlist name="EWL" type="os_thread_t" offset="ECB[i].thread_list" next="thread_next" />

        <calc>
          ECB[i].wl_cnt = (EWL._count - k);
          k = EWL._count;
        </calc>

        <!-- Read name string -->
        <calc cond="ECB[i].name">
          ECB[i].obj_name[0] = ',';
          ECB[i].obj_name[1] = ' ';
        </calc>
        <list cond="ECB[i].name" name="n" start="0" limit="64">
          <read name="ch2" type="uint8_t" offset="ECB[i].name + n"/>

          <calc>
            ECB[i].obj_name[2+n] = ch2;
          </calc>

          <calc cond="ch2 == 0">
            n = 64;
          </calc>
        </list>
      </list>

      <!-- Validate and process Mutex control blocks -->
      <calc> k = 0; </calc>

      <list cond="MCB._count" name="i" start="0" limit="MCB._count">
        <calc>
          MCB[i].cb_valid = (MCB[i].id == 4) &amp;&amp; (MCB[i].state == 1);
          MCB[i].wl_idx  = k;
        </calc>

        <!-- Create a list of threads waiting for mutex -->
        <readlist name="MWL" type="os_thread_t" offset="MCB[i].thread_list" next="thread_next" />

        <calc>
          MCB[i].wl_cnt = (MWL._count - k);
          k = MWL._count;
        </calc>

        <!-- Read name string -->
        <calc cond="MCB[i].name">
          MCB[i].obj_name[0] = ',';
          MCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="MCB[i].name" name="n" start="0" limit="64">
          <read name="ch3" type="uint8_t" offset="MCB[i].name + n"/>

          <calc>
            MCB[i].obj_name[2+n] = ch3;
          </calc>

          <calc cond="ch3 == 0">
            n = 64;
          </calc>
        </list>
      </list>


      <!-- Validate and process semaphore control blocks -->
      <calc> k = 0; </calc>

      <list cond="SCB._count" name="i" start="0" limit="SCB._count">
        <calc>
          SCB[i].cb_valid = (SCB[i].id == 5) &amp;&amp; (SCB[i].state == 1);
          SCB[i].wl_idx  = k;
        </calc>

        <!-- Create a list of threads waiting for semaphore -->
        <readlist name="SWL" type="os_thread_t" offset="SCB[i].thread_list" next="thread_next" />

        <calc>
          SCB[i].wl_cnt = (SWL._count - k);
          k = SWL._count;
        </calc>

        <!-- Read name string -->
        <calc cond="SCB[i].name">
          SCB[i].obj_name[0] = ',';
          SCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="SCB[i].name" name="n" start="0" limit="64">
          <read name="ch4" type="uint8_t" offset="SCB[i].name + n"/>

          <calc>
            SCB[i].obj_name[2+n] = ch4;
          </calc>

          <calc cond="ch4 == 0">
            n = 64;
          </calc>
        </list>
      </list>

      <!-- Validate and process MemoryPool control blocks -->
      <calc> k = 0; </calc>

      <list cond="PCB._count" name="i" start="0" limit="PCB._count">
        <calc>
          PCB[i].cb_valid = (PCB[i].id == 6) &amp;&amp; (PCB[i].state == 1);
          PCB[i].wl_idx   = k;
        </calc>

        <!-- Create a list of threads waiting for memory pool -->
        <readlist name="PWL" type="os_thread_t" offset="PCB[i].thread_list" next="thread_next" />

        <calc>
          PCB[i].wl_cnt = (PWL._count - k);
          k = PWL._count;
        </calc>

        <!-- Read name string -->
        <calc cond="PCB[i].name">
          PCB[i].obj_name[0] = ',';
          PCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="PCB[i].name" name="n" start="0" limit="64">
          <read name="ch5" type="uint8_t" offset="PCB[i].name + n"/>

          <calc>
            PCB[i].obj_name[2+n] = ch5;
          </calc>

          <calc cond="ch5 == 0">
            n = 64;
          </calc>
        </list>
      </list>


      <!-- Validate and process MessageQueue control blocks -->
      <calc> k = 0; j = 0; </calc>

      <list cond="QCB._count" name="i" start="0" limit="QCB._count">
        <calc>
          QCB[i].cb_valid = (QCB[i].id == 8) &amp;&amp; (QCB[i].state == 1);
          QCB[i].wl_idx = k;
        </calc>

        <!-- Create a list of threads waiting for message queue -->
        <readlist name="QWL" type="os_thread_t" offset="QCB[i].thread_list" next="thread_next" />

        <calc>
          QCB[i].wl_cnt = (QWL._count - k);
          k = QWL._count;
        </calc>

        <!-- Read name string -->
        <calc cond="QCB[i].name">
          QCB[i].obj_name[0] = ',';
          QCB[i].obj_name[1] = ' ';
        </calc>
        <list cond="QCB[i].name" name="n" start="0" limit="64">
          <read name="ch6" type="uint8_t" offset="QCB[i].name + n"/>

          <calc>
            QCB[i].obj_name[2+n] = ch6;
          </calc>

          <calc cond="ch6 == 0">
            n = 64;
          </calc>
        </list>

        <!-- Create a list of enqueued messages -->
        <readlist name="QML" type="os_message_t" offset="QCB[i].msg_first" next="next" />

        <calc>
          QCB[i].ml_idx = j;
          j = QML._count;
        </calc>
      </list>

      <!-- Determine the addresses of enqueued messages -->
      <list cond="QML._count" name="i" start="0" limit="QML._count">
        <calc>
          QML[i].addr  = QML[i]._addr;
          QML[i].addr += 12;
        </calc>
      </list>

      <!-- Determine what to display -->
      <list cond="TCB._count" name="i" start="0" limit="TCB._count">
        <calc>TCB_En += TCB[i].cb_valid; </calc>
      </list>
      <list cond="CCB._count" name="i" start="0" limit="CCB._count">
        <calc>CCB_En += CCB[i].cb_valid; </calc>
      </list>
      <list cond="SCB._count" name="i" start="0" limit="SCB._count">
        <calc>SCB_En += SCB[i].cb_valid; </calc>
      </list>
      <list cond="MCB._count" name="i" start="0" limit="MCB._count">
        <calc>MCB_En += MCB[i].cb_valid; </calc>
      </list>
      <list cond="ECB._count" name="i" start="0" limit="ECB._count">
        <calc>ECB_En += ECB[i].cb_valid; </calc>
      </list>
      <list cond="PCB._count" name="i" start="0" limit="PCB._count">
        <calc>PCB_En += PCB[i].cb_valid; </calc>
      </list>
      <list cond="QCB._count" name="i" start="0" limit="QCB._count">
        <calc>QCB_En += QCB[i].cb_valid; </calc>
      </list>

      <out name="RTX RTOS">
        <!-- System -->
        <item property="System" value="">
          <item property="Kernel State" value="osKernelInactive"         cond="RTX_En == 0"/>
          <item property="Kernel State" value="%E[os_Info.kernel_state]" cond="RTX_En != 0"/>
          <item property="Kernel Tick Frequency" value="%d[os_Config.tick_freq]" />
          <item property="Round Robin"         value="Disabled"                      cond="os_Config.robin_timeout == 0" />
          <item property="Round Robin Tick"    value="%d[os_Info.thread_robin_tick]" cond="(os_Config.robin_timeout > 0) &amp;&amp; (RTX_En != 0)" />
          <item property="Round Robin Timeout" value="%d[os_Config.robin_timeout]"   cond="os_Config.robin_timeout > 0" />
          <item property="Global Dynamic Memory size" value="%d[os_Config.mem_common_size]" />
          <item property="Stack Overrun Check"   value="%t[stack_check ? &quot;Enabled&quot; : &quot;Disabled&quot;]" />
          <item property="Stack Usage Watermark" value="%t[stack_wmark ? &quot;Enabled&quot; : &quot;Disabled&quot;]" />
          <item property="Default Thread Stack Size" value="%d[os_Config.thread_stack_size]" />

          <item property="ISR FIFO Queue" value="Size: %d[os_Info.isr_queue_max], Used: %d[os_Info.isr_queue_cnt]" cond="RTX_En">
            <list name="i" start="0" limit="os_Info.isr_queue_cnt">
              <item property="data[%d[i]]"    value="%x[ISR_FIFO[i]]" />
            </list>
          </item>

          <item property="Object specific Memory allocation" cond="StaticMp_En">
              <item property="Thread objects"        value="Used: %d[cfg_mp_thread.used_blocks], Max: %d[cfg_mp_thread.max_blocks]" cond="os_Config.mpi_thread" />
              <item property="Timer objects"         value="Used: %d[cfg_mp_timer.used_blocks], Max: %d[cfg_mp_timer.max_blocks]" cond="os_Config.mpi_timer" />
              <item property="Event Flags objects"   value="Used: %d[cfg_mp_events.used_blocks], Max: %d[cfg_mp_events.max_blocks]" cond="os_Config.mpi_event_flags" />
              <item property="Mutex objects"         value="Used: %d[cfg_mp_mutex.used_blocks], Max: %d[cfg_mp_mutex.max_blocks]" cond="os_Config.mpi_mutex" />
              <item property="Semaphore objects"     value="Used: %d[cfg_mp_semaphore.used_blocks], Max: %d[cfg_mp_semaphore.max_blocks]" cond="os_Config.mpi_semaphore" />
              <item property="Memory Pool objects"   value="Used: %d[cfg_mp_mpool.used_blocks], Max: %d[cfg_mp_mpool.max_blocks]" cond="os_Config.mpi_memory_pool" />
              <item property="Message Queue objects" value="Used: %d[cfg_mp_mqueue.used_blocks], Max: %d[cfg_mp_mqueue.max_blocks]" cond="os_Config.mpi_message_queue" />
          </item>
        </item>

        <!-- Threads -->
        <item cond="TCB_En" property="Threads" value="">
          <list name="i" start="0" limit="TCB._count">
            <item cond="TCB[i].cb_valid" property="id: %x[TCB[i]._addr]%t[TCB[i].obj_name]" value="%E[TCB[i].state &amp; 0x07], %E[TCB[i].priority]">
              <item property="State"        value="%E[TCB[i].state &amp; 0x07]"/>
              <item property="Priority"     value="%E[TCB[i].priority]"/>
              <item property="Attributes"   value="%E[TCB[i].attr &amp; 0x01]"/>

              <item property="Waiting" value="%E[TCB[i].state], Timeout: osWaitForever" cond="((TCB[i].state &amp; 0x07) == 3) &amp;&amp; (TCB[i].ex_delay == -1)">
                <!-- Wait Thread Flags -->
                <item cond="TCB[i].state == 0x33" property="id: %x[TCB[i].thread_prev]" value=""/>

                <list cond="TCB[i].state == 0x43" name="n" start="0" limit="ECB._count">
                  <!-- Wait Event Flags -->
                  <item cond="TCB[i].thread_prev == ECB[n]._addr" property="id: %x[ECB[n]._addr]%t[ECB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x53" name="n" start="0" limit="MCB._count">
                  <!-- Wait Mutex -->
                  <item cond="TCB[i].thread_prev == MCB[n]._addr" property="id: %x[MCB[n]._addr]%t[MCB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x63" name="n" start="0" limit="SCB._count">
                  <!-- Wait Semaphore -->
                  <item cond="TCB[i].thread_prev == SCB[n]._addr" property="id: %x[SCB[n]._addr]%t[SCB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x73" name="n" start="0" limit="PCB._count">
                  <!-- Wait Memory Pool -->
                  <item cond="TCB[i].thread_prev == PCB[n]._addr" property="id: %x[PCB[n]._addr]%t[PCB[n].obj_name]" value=""/>
                </list>

                <list cond="(TCB[i].state == 0x83) || (TCB[i].state == 0x84)" name="n" start="0" limit="QCB._count">
                  <!-- Wait Message Queue -->
                  <item cond="TCB[i].thread_prev == QCB[n]._addr" property="id: %x[QCB[n]._addr]%t[QCB[n].obj_name]" value=""/>
                </list>
              </item>

              <item property="Waiting" value="%E[TCB[i].state], Timeout: %d[TCB[i].ex_delay]" cond="((TCB[i].state &amp; 0x07) == 3) &amp;&amp; (TCB[i].ex_delay != -1)">
                <!-- Wait Thread Flags -->
                <item cond="TCB[i].state == 0x33" property="id: %x[TCB[i].thread_prev]" value=""/>

                <list cond="TCB[i].state == 0x43" name="n" start="0" limit="ECB._count">
                  <!-- Wait Event Flags -->
                  <item cond="TCB[i].thread_prev == ECB[n]._addr" property="id: %x[ECB[n]._addr]%t[ECB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x53" name="n" start="0" limit="MCB._count">
                  <!-- Wait Mutex -->
                  <item cond="TCB[i].thread_prev == MCB[n]._addr" property="id: %x[MCB[n]._addr]%t[MCB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x63" name="n" start="0" limit="SCB._count">
                  <!-- Wait Semaphore -->
                  <item cond="TCB[i].thread_prev == SCB[n]._addr" property="id: %x[SCB[n]._addr]%t[SCB[n].obj_name]" value=""/>
                </list>

                <list cond="TCB[i].state == 0x73" name="n" start="0" limit="PCB._count">
                  <!-- Wait Memory Pool -->
                  <item cond="TCB[i].thread_prev == PCB[n]._addr" property="id: %x[PCB[n]._addr]%t[PCB[n].obj_name]" value=""/>
                </list>

                <list cond="(TCB[i].state == 0x83) || (TCB[i].state == 0x84)" name="n" start="0" limit="QCB._count">
                  <!-- Wait Message Queue -->
                  <item cond="TCB[i].thread_prev == QCB[n]._addr" property="id: %x[QCB[n]._addr]%t[QCB[n].obj_name]" value=""/>
                </list>
              </item>

              <item property="Stack" value="Used: %d[TCB[i].stack_curp]%% [%d[TCB[i].stack_curb]], Max: %d[TCB[i].stack_maxp]%% [%d[TCB[i].stack_maxb]]" cond="stack_wmark != 0">
                <item property="Used"  value="%d[TCB[i].stack_curb]"/>
                <item property="Max"   value="%d[TCB[i].stack_maxb]"/>
                <item property="Top"   value="%x[TCB[i].stack_mem + TCB[i].stack_size]"/>
                <item property="Limit" value="%x[TCB[i].stack_mem]"/>
                <item property="Size"  value="%d[TCB[i].stack_size]"/>
              </item>

              <item property="Stack" value="Used: %d[TCB[i].stack_curp]%% [%d[TCB[i].stack_curb]]" cond="stack_wmark == 0">
                <item property="Used"  value="%d[TCB[i].stack_curb]"/>
                <item property="Top"   value="%x[TCB[i].stack_mem + TCB[i].stack_size]"/>
                <item property="Limit" value="%x[TCB[i].stack_mem]"/>
                <item property="Size"  value="%d[TCB[i].stack_size]"/>
              </item>

              <item property="Stack Overrun" value="Overrun detected" cond="TCB[i].stack_over != 0"/>
              <item property="Flags" value="%x[TCB[i].thread_flags]"/>
              <item property="Wait Flags" value="%x[TCB[i].wait_flags], %E[TCB[i].flags_options &amp; 1]"                   cond="(TCB[i].wait_flags != 0) &amp;&amp; ((TCB[i].flags_options &amp; 2) == 0)"/>
              <item property="Wait Flags" value="%x[TCB[i].wait_flags], %E[TCB[i].flags_options &amp; 1], osFlagsAutoClear" cond="(TCB[i].wait_flags != 0) &amp;&amp; ((TCB[i].flags_options &amp; 2) != 0)"/>
              <item property="TrustZone ID" value="%d[TCB[i].tz_memory]" cond="TCB[i].tz_memory"/>
            </item>
          </list>
        </item>

        <!-- Timers -->
        <item cond="CCB_En" property="Timers" value="">
          <list name="i" start="0" limit="CCB._count">
            <item cond="CCB[i].cb_valid" property="id: %x[CCB[i]._addr]%t[CCB[i].obj_name]" value="%E[CCB[i].state], Tick: %d[CCB[i].ex_tick]">
              <item property="State"    value="%E[CCB[i].state]" />
              <item property="Type"     value="%E[CCB[i].type]" />
              <item property="Tick"     value="%d[CCB[i].ex_tick]" />
              <item property="Load"     value="%d[CCB[i].load]" />
              <item property="Callback" value="Func: %S[CCB[i].finfo_fp], Arg: %x[CCB[i].finfo_arg]" />
            </item>
          </list>
        </item>

        <!-- Semaphores -->
        <item cond="SCB_En" property="Semaphores" value="">
          <list name="i" start="0" limit="SCB._count">
            <item cond="SCB[i].cb_valid" property="id: %x[SCB[i]._addr]%t[SCB[i].obj_name]" value="Tokens: %d[SCB[i].tokens], Max: %d[SCB[i].max_tokens]">
            <item property="Tokens"     value="%d[SCB[i].tokens]" />
            <item property="Max Tokens" value="%d[SCB[i].max_tokens]" />

              <!-- Waiting thread list -->
              <item cond="SCB[i].wl_cnt" property="Threads waiting (%d[SCB[i].wl_cnt])" value="">

                <list name="j" start="SCB[i].wl_idx" limit="SCB[i].wl_idx + SCB[i].wl_cnt">
                  <list name="k" start="0" limit="TCB._count">
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: %d[TCB[k].ex_delay]" cond="(SWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay != -1)"/>
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: osWaitForever"       cond="(SWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay == -1)"/>
                  </list>
                </list>

              </item>
            </item>
          </list>
        </item>

        <!-- Mutexes -->
        <item cond="MCB_En" property="Mutexes" value="">
          <list name="i" start="0" limit="MCB._count">
            <item cond="MCB[i].cb_valid" property="id: %x[MCB[i]._addr]%t[MCB[i].obj_name]" value="Lock counter: %d[MCB[i].lock]">
              <item property="Lock counter" value="%x[MCB[i].lock]"/>
              <item property="Attributes" value="%x[MCB[i].attr]">
                <item property="osMutexRecursive"   value="%t[(MCB[i].attr &amp; 0x01) ?  &quot;True&quot; : &quot;False&quot;]" />
                <item property="osMutexPrioInherit" value="%t[(MCB[i].attr &amp; 0x02) ?  &quot;True&quot; : &quot;False&quot;]" />
                <item property="osMutexRobust"      value="%t[(MCB[i].attr &amp; 0x08) ?  &quot;True&quot; : &quot;False&quot;]" />
              </item>

              <list cond="MCB[i].owner_thread" name="n" start="0" limit="TCB._count">
                <item cond="MCB[i].owner_thread == TCB[n]._addr" property="Owner thread" value="id: %x[TCB[n]._addr]%t[TCB[n].obj_name]"/>
              </list>

              <!-- Waiting thread list -->
              <item cond="MCB[i].wl_cnt" property="Threads waiting (%d[MCB[i].wl_cnt])" value="">

                <list name="j" start="MCB[i].wl_idx" limit="MCB[i].wl_idx + MCB[i].wl_cnt">
                  <list name="k" start="0" limit="TCB._count">
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: %d[TCB[k].ex_delay]" cond="(MWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay != -1)"/>
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: osWaitForever"       cond="(MWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay == -1)"/>
                  </list>
                </list>

              </item>
            </item>
          </list>
        </item>

        <!-- Event Flags -->
        <item cond="ECB_En" property="Event Flags" value="">
          <list name="i" start="0" limit="ECB._count">
            <item cond="ECB[i].cb_valid" property="id: %x[ECB[i]._addr]%t[ECB[i].obj_name]" value="Flags: %x[ECB[i].event_flags]">

              <!-- Waiting thread list -->
              <item cond="ECB[i].wl_cnt" property="Threads waiting (%d[ECB[i].wl_cnt])" value="">

                <list name="j" start="ECB[i].wl_idx" limit="ECB[i].wl_idx + ECB[i].wl_cnt">
                  <list name="k" start="0" limit="TCB._count">
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: %d[TCB[k].ex_delay]" cond="(EWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay != -1)"/>
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: osWaitForever"       cond="(EWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay == -1)"/>
                  </list>
                </list>

              </item>
            </item>
          </list>
        </item>

        <!-- Memory Pool -->
        <item cond="PCB_En" property="Memory Pools" value="">
          <list name="i" start="0" limit="PCB._count">
            <item cond="PCB[i].cb_valid" property="id: %x[PCB[i]._addr]%t[PCB[i].obj_name]" value="Used: %d[PCB[i].used_blocks], Max: %d[PCB[i].max_blocks]">

              <item property="Used blocks"  value="%d[PCB[i].used_blocks]"/>
              <item property="Max blocks"   value="%d[PCB[i].max_blocks]"/>
              <item property="Block size"   value="%d[PCB[i].block_size] bytes"/>
              <item property="Memory base address" value="%x[PCB[i].block_base]"/>
              <item property="Memory limit address" value="%x[PCB[i].block_lim]"/>

              <!-- Waiting thread list -->
              <item cond="PCB[i].wl_cnt" property="Threads waiting (%d[PCB[i].wl_cnt])" value="">

                <list name="j" start="PCB[i].wl_idx" limit="PCB[i].wl_idx + PCB[i].wl_cnt">
                  <list name="k" start="0" limit="TCB._count">
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: %d[TCB[k].ex_delay]" cond="(PWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay != -1)"/>
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: osWaitForever"       cond="(PWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay == -1)"/>
                  </list>
                </list>

              </item>
            </item>
          </list>
        </item>

        <!-- Message Queue -->
        <item cond="QCB_En" property="Message Queues" value="">
          <list name="i" start="0" limit="QCB._count">
            <item cond="QCB[i].cb_valid" property="id: %x[QCB[i]._addr]%t[QCB[i].obj_name]" value="Messages: %d[QCB[i].used_blocks], Max: %d[QCB[i].max_blocks]">

              <item property="Messages"     value="%d[QCB[i].msg_count]"/>
              <item property="Max Messages" value="%d[QCB[i].max_blocks]"/>
              <item property="Message size" value="Max: %d[QCB[i].msg_size] bytes"/>

              <!-- Waiting thread list -->
              <item cond="QCB[i].wl_cnt" property="Threads waiting (%d[QCB[i].wl_cnt])" value="">

                <list name="j" start="QCB[i].wl_idx" limit="QCB[i].wl_idx + QCB[i].wl_cnt">
                  <list name="k" start="0" limit="TCB._count">
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: %d[TCB[k].ex_delay]" cond="(QWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay != -1)"/>
                    <item property="id: %x[TCB[k]._addr]%t[TCB[k].obj_name]" value="Timeout: osWaitForever"       cond="(QWL[j].stack_mem == TCB[k].stack_mem) &amp;&amp; (TCB[k].ex_delay == -1)"/>
                  </list>
                </list>

              </item>

              <!-- Queued messages list-->
              <item cond="QCB[i].msg_count" property="Queue (%d[QCB[i].msg_count])" value="">

                <list name="j" start="0" limit="QCB[i].msg_count">
                  <item property="Queue[%d[j]]" value="Address: %x[QML[j + QCB[i].ml_idx].addr], Priority: %d[QML[j].priority]" />
                </list>

              </item>

            </item>
          </list>
        </item>

      </out>
    </object>
  </objects>
</component_viewer>
